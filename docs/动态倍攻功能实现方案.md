这是一份符合工程标准的完整代码实现文档。您可以直接将其归档到项目的 `docs/` 目录中，或者作为代码审查（Code Review）的依据。

***

# 功能实现文档：动态倍攻与无敌系统 (Dynamic Damage Multiplier System)

| **文档属性**   | **详情**                                 |
| ---------- | -------------------------------------- |
| **所属模块**   | `Payload\modules\helper\HelperMod.cpp` |
| **依赖库**    | MinHook                                |
| **目标游戏版本** | DNF (基于提供的内存地址)                        |
| **当前状态**   | 已实现 (硬编码地址版)                           |
| **最后更新**   | 2026-02-04                             |

***

## 1. 功能概述 (Overview)

### 1.1 功能名称

**Hook\_DamageMultiplier (伤害倍率钩子)**

### 1.2 开发目的

在不修改游戏静态文件的情况下，通过内存 Hook 技术接管游戏的伤害计算流程，实现以下两个核心目标：

1. **玩家增强**：将玩家造成的伤害通过乘法逻辑动态放大（如 x10, x100），且支持通过 GUI 实时调节倍率。
2. **怪物削弱（伪无敌）**：将怪物造成的伤害或怪物自身的攻击力强制置为 0，实现“无敌”效果。

### 1.3 技术原理

采用 **Mid-Function Hook (中间层钩子)** 技术。利用 `MinHook` 库在特定汇编指令处通过 `JMP` 跳转到自定义的**裸函数 (Naked Function)**，在保留寄存器现场的前提下修改堆栈中的参数，最后跳回原执行流。

***

## 2. 技术规格 (Technical Specifications)

### 2.1 关键内存地址 (Key Addresses)

> **注意**：当前使用硬编码地址，游戏版本更新后必须重新获取。

| **参数名称**              | **地址/偏移**  | **说明**                            |
| --------------------- | ---------- | --------------------------------- |
| **Hook Address**      | `0x884FCB` | 伤害计算/参数传递的关键汇编指令位置                |
| **Actor Type Offset** | `0x644`    | 相对于对象基址 (`ECX`) 的偏移，用于判断对象是玩家还是怪物 |
| **Arg Stack Offset**  | `0x10`     | 相对于栈帧基址 (`EBP`) 的偏移，存放伤害数值        |

### 2.2 逻辑判定规则

- **玩家判定**：`Read(ECX + 0x644) == 0`

- **怪物判定**：`Read(ECX + 0x644) != 0`

***

## 3. 详细设计 (Detailed Design)

### 3.1 数据流图 (Flowchart)

代码段

```
graph TD
    A[游戏执行到 0x884FCB] --> B{MinHook跳转};
    B --> C[进入 DamageHookDetour];
    C --> D[保存寄存器 PUSH EAX/EDX];
    D --> E{判断 ECX+0x644};
    
    E -- 等于 0 (玩家) --> F[读取栈中伤害值];
    F --> G[IMUL 乘以全局倍率 g_DamageMultiplier];
    G --> H[写回栈内存];
    
    E -- 不等于 0 (怪物) --> I[将栈中伤害值置为 0];
    
    H --> J[恢复寄存器 POP EDX/EAX];
    I --> J;
    
    J --> K[跳转到 Trampoline (执行原指令并返回)];
```

### 3.2 寄存器管理

由于在计算过程中使用了 `EAX` 和 `EDX` 进行乘法运算，且原游戏指令 `mov [ebp-190], eax` 依赖进入 Hook 点前的 `EAX` 值，因此必须严格遵守 **"先保存，后恢复"** 的原则。

***

## 4. 代码实现 (Implementation)

将以下代码集成至 `Payload\modules\helper\HelperMod.cpp`。

C++

```
#include "pch.h"
#include <vector>

// ==========================================
//              配置与全局变量
// ==========================================

// 目标 Hook 地址 (需随版本更新维护)
uintptr_t g_DamageHookAddress = 0x884FCB; 

// 内存偏移常量
const uintptr_t OFFSET_ACTOR_TYPE = 0x644;  // [ECX + 0x644] 阵营判断
const uintptr_t OFFSET_STACK_ARG3 = 0x10;   // [EBP + 0x10]  伤害参数

// 动态控制参数
// 建议在 GUI 模块绑定此变量指针，实现滑块调节
int g_DamageMultiplier = 10; 

// MinHook 跳板函数指针
void* g_fpDamageTrampoline = nullptr;

namespace Helper {

    // ==========================================
    //           核心裸函数实现
    // ==========================================
    // __declspec(naked) 确保编译器不生成函数序言/结语
    // 从而让我们能完全控制堆栈和寄存器
    void __declspec(naked) DamageHookDetour() {
        __asm {
            // [Step 1] 保护现场
            // -------------------------------------------------
            // 原地保存 EAX 和 EDX，防止破坏游戏上下文
            push eax
            push edx

            // [Step 2] 敌我识别
            // -------------------------------------------------
            // 读取对象类型：DWORD PTR [ECX + 0x644]
            cmp dword ptr [ecx + OFFSET_ACTOR_TYPE], 0
            jne IsMonsterLabel  // 非 0 则跳转至怪物处理逻辑

            // [Step 3-A] 玩家逻辑：倍攻计算
            // -------------------------------------------------
            // 读取原伤害值
            mov eax, dword ptr [ebp + OFFSET_STACK_ARG3]
            
            // 执行有符号乘法：EAX = EAX * g_DamageMultiplier
            imul eax, g_DamageMultiplier
            
            // 写回修改后的伤害值
            mov dword ptr [ebp + OFFSET_STACK_ARG3], eax
            
            // 处理完毕，跳转至退出流程
            jmp ExitHookLabel

        IsMonsterLabel:
            // [Step 3-B] 怪物逻辑：伤害无效化
            // -------------------------------------------------
            // 直接将伤害参数置为 0
            mov dword ptr [ebp + OFFSET_STACK_ARG3], 0

        ExitHookLabel:
            // [Step 4] 恢复现场
            // -------------------------------------------------
            // 必须按与 PUSH 相反的顺序 POP
            pop edx
            pop eax 

            // [Step 5] 返回游戏主流程
            // -------------------------------------------------
            // 跳转至 MinHook 生成的跳板，它会负责：
            // 1. 执行被覆盖的原指令 (mov [ebp-190], eax)
            // 2. 跳转回 Hook 地址 + 指令长度的位置
            jmp [g_fpDamageTrampoline]
        }
    }

    // ==========================================
    //           对外接口：安装 Hook
    // ==========================================
    bool InstallDamageHook() {
        // 安全检查
        if (g_DamageHookAddress == 0) return false;

        // 1. 创建 Hook
        MH_STATUS status = MH_CreateHook(
            (LPVOID)g_DamageHookAddress,    // 目标地址
            &DamageHookDetour,              // 我们的函数
            &g_fpDamageTrampoline           // 接收跳板指针
        );

        if (status != MH_OK) {
            OutputDebugStringA("[Helper] Error: Failed to create damage hook.");
            return false;
        }

        // 2. 启用 Hook
        status = MH_EnableHook((LPVOID)g_DamageHookAddress);
        if (status != MH_OK) {
            OutputDebugStringA("[Helper] Error: Failed to enable damage hook.");
            return false;
        }

        OutputDebugStringA("[Helper] Info: Damage Hook installed successfully at 0x884FCB.");
        return true;
    }
}
```

***

