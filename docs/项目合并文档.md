
---

# âš”ï¸ game-all å®Œæ•´å·¥ç¨‹åˆå¹¶æ–¹æ¡ˆ

## ğŸ¯ é¡¹ç›®ç›®æ ‡

æ„å»ºä¸€ä¸ªåä¸º `game-all` çš„è§£å†³æ–¹æ¡ˆï¼ŒåŒ…å«ä»¥ä¸‹ä¸‰ä¸ªæ ¸å¿ƒç»„ä»¶ï¼š

1. **Payload (game-payload.dll)** : x86 DLLï¼Œåˆå¹¶äº†æ¸¸æˆè¾…åŠ© (Helper) å’ŒåŒæ­¥å™¨ (Sync) çš„æ ¸å¿ƒé€»è¾‘ã€‚
2. **Injector (game-injector.exe)** : x86 æ§åˆ¶å°ç¨‹åºï¼Œé‡‡ç”¨ APC æŠ€æœ¯å°† DLL æ³¨å…¥æ¸¸æˆã€‚
3. **MasterGUI (game-master.exe)** : C# WPF ç¨‹åºï¼Œæä¾›åŒåŠŸèƒ½æ§åˆ¶é¢æ¿ã€‚

---

## ç¬¬ä¸€é˜¶æ®µï¼šç›®å½•ç»“æ„é‡ç»„ (æ‰‹åŠ¨æ“ä½œ)

è¯·åœ¨ç£ç›˜ä¸Šåˆ›å»ºä¸€ä¸ªåä¸º `game-all` çš„æ–‡ä»¶å¤¹ï¼Œå¹¶ä¸¥æ ¼æŒ‰ä»¥ä¸‹ç»“æ„ç»„ç»‡æ–‡ä»¶ã€‚

> **âš ï¸ æ³¨æ„** ï¼šæ ‡æœ‰ `[æ¬è¿]` çš„æ–‡ä»¶éœ€è¦æ‚¨ä»åŸé¡¹ç›®ä¸­å¤åˆ¶è¿‡æ¥ã€‚

**Plaintext**

```
game-all/
â”œâ”€â”€ ğŸ“ Payload/                       <-- [C++ DLL é¡¹ç›®] è¾“å‡º: game-payload.dll
â”‚   â”œâ”€â”€ ğŸ“ lib/                       <-- ç¬¬ä¸‰æ–¹åº“ç›®å½•
â”‚   â”‚   â””â”€â”€ ğŸ“ MinHook/               <-- MinHook åº“ (å¿…é¡»æ”¾è¿™é‡Œ)
â”‚   â”‚       â”œâ”€â”€ MinHook.h             <-- [æ¬è¿]
â”‚   â”‚       â””â”€â”€ MinHook.x86.lib       <-- [æ¬è¿]
â”‚   â”œâ”€â”€ ğŸ“ modules/
â”‚   â”‚   â”œâ”€â”€ ğŸ“ helper/                <-- [æ¬è¿] åŸ version-inject ç›®å½•ä¸‹çš„ .h/.cpp
â”‚   â”‚   â”‚   â””â”€â”€ HelperMod.cpp         <-- [é‡å‘½å] ç”± version_proxy.cpp æ”¹åè€Œæ¥
â”‚   â”‚   â””â”€â”€ ğŸ“ sync/                  <-- [æ¬è¿] åŸ dnfinput ç›®å½•ä¸‹çš„ .h/.cpp
â”‚   â”‚       â””â”€â”€ SyncMod.cpp           <-- [é‡å‘½å] ç”± dnfinput.cpp æ”¹åè€Œæ¥
â”‚   â”œâ”€â”€ dllmain.cpp                   <-- [æ–°å»º] ç»Ÿä¸€å…¥å£ (ä»£ç è§ä¸‹æ–‡)
â”‚   â”œâ”€â”€ pch.h                         <-- [æ–°å»º] é¢„ç¼–è¯‘å¤´ (ä»£ç è§ä¸‹æ–‡)
â”‚   â””â”€â”€ pch.cpp                       <-- [æ–°å»º] é¢„ç¼–è¯‘æºæ–‡ä»¶
â”‚
â”œâ”€â”€ ğŸ“ Injector/                      <-- [C++ Console é¡¹ç›®] è¾“å‡º: game-injector.exe
â”‚   â””â”€â”€ main.cpp                      <-- [æ–°å»º] APC æ³¨å…¥å™¨æºç  (ä»£ç è§ä¸‹æ–‡)
â”‚
â””â”€â”€ ğŸ“ GUI/                           <-- [C# WPF é¡¹ç›®] è¾“å‡º: game-master.exe
    â”œâ”€â”€ App.xaml
    â”œâ”€â”€ MainWindow.xaml               <-- [ä¿®æ”¹] åŒ…å« TabControl çš„ä¸»ç•Œé¢
    â”œâ”€â”€ ğŸ“ Modules/
    â”‚   â”œâ”€â”€ ğŸ“ Helper/                <-- [æ¬è¿] åŸ GameHelperGUI ä»£ç 
    â”‚   â””â”€â”€ ğŸ“ Sync/                  <-- [æ¬è¿] åŸ DNFSyncBox ä»£ç 
    â””â”€â”€ ...
```

---

## ç¬¬äºŒé˜¶æ®µï¼šPayload (DLL) ä»£ç æ”¹é€ 

### 1. é…ç½®é¢„ç¼–è¯‘å¤´ (`Payload/pch.h`)

åœ¨ VS ä¸­è®¾ç½®é¡¹ç›®ä½¿ç”¨é¢„ç¼–è¯‘å¤´ï¼Œå†…å®¹å¦‚ä¸‹ï¼š

**C++**

```
#pragma once
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <vector>
#include <string>
#include <iostream>

// å¼•å…¥ MinHook (è·¯å¾„å·²åœ¨ç¬¬ä¸€é˜¶æ®µè§„åˆ’å¥½)
#include "../lib/MinHook/MinHook.h"
```

### 2. æ”¹é€  Helper æ¨¡å— (`HelperMod.cpp`)

 **æ“ä½œå¯¹è±¡** ï¼š`Payload/modules/helper/HelperMod.cpp` (åŸ `version_proxy.cpp`)

* **ä¿®æ”¹ç‚¹ 1** ï¼šåˆ é™¤ `#include "version_exports.h"` åŠæ‰€æœ‰ `#pragma comment(linker, ...)`ã€‚
* **ä¿®æ”¹ç‚¹ 2** ï¼šåœ¨æ–‡ä»¶é¦–å°¾æ·»åŠ  `namespace Helper { ... }`ã€‚
* **ä¿®æ”¹ç‚¹ 3** ï¼šåˆ é™¤åŸæœ‰çš„ `DllMain`ï¼Œæ”¹ä¸º `Start` å‡½æ•°ã€‚

**C++**

```
// åœ¨ namespace Helper { å†…éƒ¨çš„æœ«å°¾ ...

    // [æ–°å¢] å¯åŠ¨æ¥å£
    void Start() {
        // æ¨¡æ‹ŸåŸ DllMain çš„åˆå§‹åŒ–é€»è¾‘
        // æ³¨æ„ï¼šg_self_module å˜é‡éœ€è¦åœ¨æœ¬æ–‡ä»¶é¡¶éƒ¨å£°æ˜è¿‡
        g_self_module = GetModuleHandleA(NULL); 
      
        // å¯åŠ¨å·¥ä½œçº¿ç¨‹ (ä¿ç•™åŸé€»è¾‘)
        HANDLE thread = CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);
        if (thread) CloseHandle(thread);
    }

    void Stop() {
        // æ¸…ç†é€»è¾‘
    }
} // namespace Helper ç»“æŸ
```

### 3. æ”¹é€  Sync æ¨¡å— (`SyncMod.cpp`)

 **æ“ä½œå¯¹è±¡** ï¼š`Payload/modules/sync/SyncMod.cpp` (åŸ `dnfinput.cpp`)

* åŒæ ·åŒ…è£¹ `namespace Sync { ... }`ã€‚
* åˆ é™¤ `DllMain`ï¼Œå°†åˆå§‹åŒ–é€»è¾‘å°è£…è¿› `Sync::Start()`ã€‚

### 4. ç¼–å†™ç»Ÿä¸€å…¥å£ (`Payload/dllmain.cpp`)

**C++**

```
#include "pch.h"
#include <atomic>

// å£°æ˜å­æ¨¡å—æ¥å£
namespace Helper { void Start(); void Stop(); }
namespace Sync   { void Start(); void Stop(); }

std::atomic<bool> g_IsInitialized(false);

DWORD WINAPI UnifiedInitThread(LPVOID lpParam) {
    // 1. åˆå§‹åŒ– MinHook (åªéœ€ä¸€æ¬¡)
    if (MH_Initialize() != MH_OK) {
        OutputDebugStringA("[game-all] MinHook init failed!");
    }

    // 2. å¯åŠ¨åŒæ­¥æ¨¡å— (å»ºè®®å…ˆå¯åŠ¨ Input Hook)
    Sync::Start();

    // 3. å¯åŠ¨è¾…åŠ©æ¨¡å—
    Helper::Start();

    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        // åŸå­é”é˜²æ­¢ APC é‡å¤è§¦å‘
        bool expected = false;
        if (g_IsInitialized.compare_exchange_strong(expected, true)) {
            DisableThreadLibraryCalls(hModule);
            // å¼€å¯æ–°çº¿ç¨‹è¿›è¡Œåˆå§‹åŒ–ï¼Œé¿å… Loader Lock æ­»é”
            CreateThread(NULL, 0, UnifiedInitThread, NULL, 0, NULL);
        }
        break;
    }
    return TRUE;
}
```

---

## ç¬¬ä¸‰é˜¶æ®µï¼šInjector (æ³¨å…¥å™¨) ä»£ç å®ç°

 **æ“ä½œå¯¹è±¡** ï¼š`Injector/main.cpp`

è¿™æ˜¯åŸºäº `APCinjecter.cpp` ä¼˜åŒ–åçš„ç‰ˆæœ¬ï¼Œå¢åŠ äº†ææƒå’Œç­‰å¾…åŠŸèƒ½ã€‚

**C++**

```
#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>

// æ—¥å¿—è¾…åŠ©
void Log(const std::wstring& msg) { std::wcout << L"[Injector] " << msg << std::endl; }

// 1. ææƒ (SeDebugPrivilege)
bool EnableDebugPrivilege() {
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) return false;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) { CloseHandle(hToken); return false; }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) { CloseHandle(hToken); return false; }
    CloseHandle(hToken);
    return (GetLastError() == ERROR_SUCCESS);
}

// 2. æŸ¥æ‰¾ PID
DWORD FindProcessId(const std::wstring& processName) {
    PROCESSENTRY32W pe32 = { sizeof(PROCESSENTRY32W) };
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return 0;
    DWORD pid = 0;
    if (Process32FirstW(hSnapshot, &pe32)) {
        do {
            if (processName == pe32.szExeFile) { pid = pe32.th32ProcessID; break; }
        } while (Process32NextW(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);
    return pid;
}

// 3. APC æ³¨å…¥
bool PerformApcInjection(DWORD pid, const std::wstring& dllPath) {
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) return false;

    size_t size = (dllPath.length() + 1) * sizeof(wchar_t);
    LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_READWRITE);
    if (!remoteMem) { CloseHandle(hProcess); return false; }

    if (!WriteProcessMemory(hProcess, remoteMem, dllPath.c_str(), size, NULL)) {
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // âš ï¸ å…³é”®ï¼šå¿…é¡»ç¼–è¯‘ä¸º x86ï¼Œå¦åˆ™ kernel32 åœ°å€ä¸åŒ¹é…
    PAPCFUNC pLoadLibrary = (PAPCFUNC)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW");
  
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    THREADENTRY32 te32 = { sizeof(THREADENTRY32) };
    int queued = 0;

    if (Thread32First(hSnapshot, &te32)) {
        do {
            if (te32.th32OwnerProcessID == pid) {
                HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);
                if (hThread) {
                    if (QueueUserAPC(pLoadLibrary, hThread, (ULONG_PTR)remoteMem)) queued++;
                    CloseHandle(hThread);
                }
            }
        } while (Thread32Next(hSnapshot, &te32));
    }
    CloseHandle(hSnapshot);
    CloseHandle(hProcess);
    return queued > 0;
}

int main() {
    SetConsoleTitleW(L"game-all Injector");
    if (!EnableDebugPrivilege()) Log(L"Warning: Failed to enable Debug Privilege.");

    wchar_t path[MAX_PATH];
    GetCurrentDirectoryW(MAX_PATH, path);
    std::wstring dllPath = std::wstring(path) + L"\\game-payload.dll"; // ç›®æ ‡ DLL åç§°

    Log(L"Waiting for DNF.exe...");
    DWORD pid = 0;
    while ((pid = FindProcessId(L"DNF.exe")) == 0) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }

    Log(L"Found PID: " + std::to_wstring(pid));
    std::this_thread::sleep_for(std::chrono::milliseconds(2000)); // ç­‰å¾…åˆå§‹åŒ–

    if (PerformApcInjection(pid, dllPath)) Log(L"Injection Success!");
    else Log(L"Injection Failed.");

    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 0;
}
```

---

## ç¬¬å››é˜¶æ®µï¼šVisual Studio å…³é”®é…ç½®æ£€æŸ¥

ä¸ºä¿è¯ç¼–è¯‘é€šè¿‡ä¸”è¿è¡Œæ­£å¸¸ï¼Œè¯·å¯¹ `Payload` å’Œ `Injector` é¡¹ç›®æ‰§è¡Œä»¥ä¸‹æ£€æŸ¥ï¼š

| **é¡¹ç›®**     | **å±æ€§é¡µè·¯å¾„** | **è®¾ç½®é¡¹** | **å€¼**                   | **è¯´æ˜**         |
| ------------------ | -------------------- | ---------------- | ------------------------------ | ---------------------- |
| **Payload**  | C/C++ -> å¸¸è§„        | é™„åŠ åŒ…å«ç›®å½•     | `$(ProjectDir)lib\MinHook`   | è®©ä»£ç èƒ½æ‰¾åˆ° MinHook.h |
| **Payload**  | é“¾æ¥å™¨ -> å¸¸è§„       | é™„åŠ åº“ç›®å½•       | `$(ProjectDir)lib\MinHook`   | è®©é“¾æ¥å™¨èƒ½æ‰¾åˆ° .lib    |
| **Payload**  | é“¾æ¥å™¨ -> è¾“å…¥       | é™„åŠ ä¾èµ–é¡¹       | `MinHook.x86.lib`            | é“¾æ¥ MinHook           |
| **Both**     | é¡¶æ å·¥å…·æ¡           | è§£å†³æ–¹æ¡ˆå¹³å°     | **x86**                  | å¿…é¡»æ˜¯ 32 ä½           |
| **Both**     | å±æ€§ -> å¸¸è§„         | å­—ç¬¦é›†           | **ä½¿ç”¨ Unicode å­—ç¬¦é›†**  | æ”¯æŒä¸­æ–‡è·¯å¾„           |
| **Both**     | C/C++ -> ä»£ç ç”Ÿæˆ    | è¿è¡Œåº“           | **å¤šçº¿ç¨‹ (/MT)**         | é™æ€é“¾æ¥ï¼Œé¿å…ç¼ºå°‘ DLL |
| **Injector** | é“¾æ¥å™¨ -> æ¸…å•æ–‡ä»¶   | UAC æ‰§è¡Œçº§åˆ«     | **requireAdministrator** | è‡ªåŠ¨è¯·æ±‚ç®¡ç†å‘˜æƒé™     |

---

## ç¬¬äº”é˜¶æ®µï¼šå…±äº«å†…å­˜ä¸€è‡´æ€§æ£€æŸ¥

è¿™æ˜¯æœ€åä¸€æ­¥ï¼Œç¡®ä¿ GUI èƒ½æ§åˆ¶ DLLã€‚

1. åœ¨ `Payload/modules/helper/HelperMod.cpp` ä¸­æœç´¢ `CreateFileMapping`ï¼Œç¡®è®¤åç§°ä¸ºï¼š
   `"Global\\GameHelperStatus_"` (æˆ–è€…æ‚¨å®šä¹‰çš„ç‰¹å®šåç§°)
2. åœ¨ `GUI` é¡¹ç›®çš„ C# ä»£ç ä¸­ï¼Œç¡®ä¿ `SharedMemoryReader` ä½¿ç”¨**å®Œå…¨ç›¸åŒ**çš„å­—ç¬¦ä¸²å‰ç¼€ã€‚

å®Œæˆä»¥ä¸Šæ­¥éª¤åï¼Œç‚¹å‡» Visual Studio çš„  **"ç”Ÿæˆè§£å†³æ–¹æ¡ˆ"** ï¼Œæ‚¨å°†åœ¨ Release ç›®å½•ä¸‹å¾—åˆ° `game-payload.dll` å’Œ `game-injector.exe`ï¼Œç›´æ¥è¿è¡Œ Injector å³å¯å¼€å§‹ä½¿ç”¨ã€‚
