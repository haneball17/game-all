
---

# ⚔️ game-all 完整工程合并方案

## 🎯 项目目标

构建一个名为 `game-all` 的解决方案，包含以下三个核心组件：

1. **Payload (game-payload.dll)** : x86 DLL，合并了游戏辅助 (Helper) 和同步器 (Sync) 的核心逻辑。
2. **Injector (game-injector.exe)** : x86 控制台程序，采用 APC 技术将 DLL 注入游戏。
3. **MasterGUI (game-master.exe)** : C# WPF 程序，提供双功能控制面板。

---

## ✅ 工程落地决策（已确认）

1. **协议单一来源方式**：不引入自动生成体系，采用 **Shared/Protocols/** 作为协议“单一来源”。
   - 目标：减少 C++/C# 结构体不一致风险，确保版本一致性。
   - 要求：所有共享内存结构体定义与版本号必须集中维护在 `Shared/Protocols/`。
2. **MasterGUI 与 Injector 关系**：采用**半集成**模式。
   - MasterGUI 仅提供“快捷入口（打开注入器目录/按钮）”与“状态检测提示”。
   - MasterGUI **不直接负责**启动/停止注入器逻辑，降低权限与耦合风险。
3. **GUI 目标框架统一**：所有 GUI 项目统一为 **net8.0-windows**。
   - 目标：减少运行时差异与发布复杂度。
   - 要求：统一 `TargetFramework`，并同步更新相关依赖。

---

## 第一阶段：目录结构重组 (手动操作)

请在磁盘上创建一个名为 `game-all` 的文件夹，并严格按以下结构组织文件。

> **⚠️ 注意** ：标有 `[搬运]` 的文件需要您从原项目中复制过来。

**Plaintext**

```
game-all/
├── 📁 Shared/
│   └── 📁 Protocols/                 <-- [新建] 协议单一来源（C++/C# 对齐）
├── 📁 Payload/                       <-- [C++ DLL 项目] 输出: game-payload.dll
│   ├── 📁 lib/                       <-- 第三方库目录
│   │   └── 📁 MinHook/               <-- MinHook 库 (必须放这里)
│   │       ├── MinHook.h             <-- [搬运]
│   │       └── MinHook.x86.lib       <-- [搬运]
│   ├── 📁 modules/
│   │   ├── 📁 helper/                <-- [搬运] 原 version-inject 目录下的 .h/.cpp
│   │   │   └── HelperMod.cpp         <-- [重命名] 由 version_proxy.cpp 改名而来
│   │   └── 📁 sync/                  <-- [搬运] 原 dnfinput 目录下的 .h/.cpp
│   │       └── SyncMod.cpp           <-- [重命名] 由 dnfinput.cpp 改名而来
│   ├── dllmain.cpp                   <-- [新建] 统一入口 (代码见下文)
│   ├── pch.h                         <-- [新建] 预编译头 (代码见下文)
│   └── pch.cpp                       <-- [新建] 预编译源文件
│
├── 📁 Injector/                      <-- [C++ Console 项目] 输出: game-injector.exe
│   └── main.cpp                      <-- [新建] APC 注入器源码 (代码见下文)
│
└── 📁 GUI/                           <-- [C# WPF 项目] 输出: game-master.exe
    ├── App.xaml
    ├── MainWindow.xaml               <-- [修改] 包含 TabControl 的主界面
    ├── 📁 Modules/
    │   ├── 📁 Helper/                <-- [搬运] 原 GameHelperGUI 代码
    │   └── 📁 Sync/                  <-- [搬运] 原 DNFSyncBox 代码
    └── ...
```

---

## 协议单一来源（Shared/Protocols）

**目标**：统一 C++ 与 C# 的共享内存结构定义与版本号，降低结构体错位风险。

**做法**：

1. 在 `Shared/Protocols/` 中维护协议定义文档（建议按模块拆分）：
   - `HelperStatusV2`、`HelperControlV1`
   - `SharedKeyboardStateV2`
2. **强制版本与大小校验**：
   - GUI 端：读取/写入时校验 `Version` 与 `Size`。
   - Payload 端：写入/读取共享内存时，同样进行 `Version` 与 `Size` 校验。
3. 任何协议变更必须先更新 `Shared/Protocols/`，再改代码。

**示例**（通俗说明）：

> “结构体定义就像一张表格，C++ 和 C# 都必须用同一份模板，否则字段会错位。”

---

## 协议引用（必读）

**唯一权威**：`Shared/Protocols/协议说明.md`

**要求**：

- 协议字段、版本号、大小校验必须以该文件为准。
- 任何代码变更前，先更新协议说明，再同步 C++ 与 C# 实现。
- 代码审查时以协议说明为对照，确保字段顺序与类型一致。

---

## 第二阶段：Payload (DLL) 代码改造

### 1. 配置预编译头 (`Payload/pch.h`)

在 VS 中设置项目使用预编译头，内容如下：

**C++**

```
#pragma once
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <vector>
#include <string>
#include <iostream>

// 引入 MinHook (路径已在第一阶段规划好)
#include "../lib/MinHook/MinHook.h"
```

### 2. 改造 Helper 模块 (`HelperMod.cpp`)

 **操作对象** ：`Payload/modules/helper/HelperMod.cpp` (原 `version_proxy.cpp`)

* **修改点 1** ：删除 `#include "version_exports.h"` 及所有 `#pragma comment(linker, ...)`。
* **修改点 2** ：在文件首尾添加 `namespace Helper { ... }`。
* **修改点 3** ：删除原有的 `DllMain`，改为 `Start` 函数。

**C++**

```
// 在 namespace Helper { 内部的末尾 ...

    // [新增] 启动接口
    void Start() {
        // 模拟原 DllMain 的初始化逻辑
        // 注意：g_self_module 变量需要在本文件顶部声明过
        g_self_module = GetModuleHandleA(NULL); 
      
        // 启动工作线程 (保留原逻辑)
        HANDLE thread = CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);
        if (thread) CloseHandle(thread);
    }

    void Stop() {
        // 清理逻辑
    }
} // namespace Helper 结束
```

### 3. 改造 Sync 模块 (`SyncMod.cpp`)

 **操作对象** ：`Payload/modules/sync/SyncMod.cpp` (原 `dnfinput.cpp`)

* 同样包裹 `namespace Sync { ... }`。
* 删除 `DllMain`，将初始化逻辑封装进 `Sync::Start()`。

### 4. 编写统一入口 (`Payload/dllmain.cpp`)

**C++**

```
#include "pch.h"
#include <atomic>

// 声明子模块接口
namespace Helper { void Start(); void Stop(); }
namespace Sync   { void Start(); void Stop(); }

std::atomic<bool> g_IsInitialized(false);

DWORD WINAPI UnifiedInitThread(LPVOID lpParam) {
    // 1. 初始化 MinHook (只需一次)
    if (MH_Initialize() != MH_OK) {
        OutputDebugStringA("[game-all] MinHook init failed!");
    }

    // 2. 启动同步模块 (建议先启动 Input Hook)
    Sync::Start();

    // 3. 启动辅助模块
    Helper::Start();

    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        // 原子锁防止 APC 重复触发
        bool expected = false;
        if (g_IsInitialized.compare_exchange_strong(expected, true)) {
            DisableThreadLibraryCalls(hModule);
            // 开启新线程进行初始化，避免 Loader Lock 死锁
            CreateThread(NULL, 0, UnifiedInitThread, NULL, 0, NULL);
        }
        break;
    }
    return TRUE;
}
```

---

## 第三阶段：Injector (注入器) 代码实现

 **操作对象** ：`Injector/main.cpp`

这是基于 `APCinjecter.cpp` 优化后的版本，增加了提权和等待功能。

**C++**

```
#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>

// 日志辅助
void Log(const std::wstring& msg) { std::wcout << L"[Injector] " << msg << std::endl; }

// 1. 提权 (SeDebugPrivilege)
bool EnableDebugPrivilege() {
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) return false;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) { CloseHandle(hToken); return false; }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) { CloseHandle(hToken); return false; }
    CloseHandle(hToken);
    return (GetLastError() == ERROR_SUCCESS);
}

// 2. 查找 PID
DWORD FindProcessId(const std::wstring& processName) {
    PROCESSENTRY32W pe32 = { sizeof(PROCESSENTRY32W) };
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return 0;
    DWORD pid = 0;
    if (Process32FirstW(hSnapshot, &pe32)) {
        do {
            if (processName == pe32.szExeFile) { pid = pe32.th32ProcessID; break; }
        } while (Process32NextW(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);
    return pid;
}

// 3. APC 注入
bool PerformApcInjection(DWORD pid, const std::wstring& dllPath) {
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) return false;

    size_t size = (dllPath.length() + 1) * sizeof(wchar_t);
    LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_READWRITE);
    if (!remoteMem) { CloseHandle(hProcess); return false; }

    if (!WriteProcessMemory(hProcess, remoteMem, dllPath.c_str(), size, NULL)) {
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // ⚠️ 关键：必须编译为 x86，否则 kernel32 地址不匹配
    PAPCFUNC pLoadLibrary = (PAPCFUNC)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW");
  
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    THREADENTRY32 te32 = { sizeof(THREADENTRY32) };
    int queued = 0;

    if (Thread32First(hSnapshot, &te32)) {
        do {
            if (te32.th32OwnerProcessID == pid) {
                HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);
                if (hThread) {
                    if (QueueUserAPC(pLoadLibrary, hThread, (ULONG_PTR)remoteMem)) queued++;
                    CloseHandle(hThread);
                }
            }
        } while (Thread32Next(hSnapshot, &te32));
    }
    CloseHandle(hSnapshot);
    CloseHandle(hProcess);
    return queued > 0;
}

int main() {
    SetConsoleTitleW(L"game-all Injector");
    if (!EnableDebugPrivilege()) Log(L"Warning: Failed to enable Debug Privilege.");

    wchar_t path[MAX_PATH];
    GetCurrentDirectoryW(MAX_PATH, path);
    std::wstring dllPath = std::wstring(path) + L"\\game-payload.dll"; // 目标 DLL 名称

    Log(L"Waiting for DNF.exe...");
    DWORD pid = 0;
    while ((pid = FindProcessId(L"DNF.exe")) == 0) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }

    Log(L"Found PID: " + std::to_wstring(pid));
    std::this_thread::sleep_for(std::chrono::milliseconds(2000)); // 等待初始化

    if (PerformApcInjection(pid, dllPath)) Log(L"Injection Success!");
    else Log(L"Injection Failed.");

    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 0;
}
```

---

## 第四阶段：Visual Studio 关键配置检查

为保证编译通过且运行正常，请对 `Payload` 和 `Injector` 项目执行以下检查：

| **项目**     | **属性页路径** | **设置项** | **值**                   | **说明**         |
| ------------------ | -------------------- | ---------------- | ------------------------------ | ---------------------- |
| **Payload**  | C/C++ -> 常规        | 附加包含目录     | `$(ProjectDir)lib\MinHook`   | 让代码能找到 MinHook.h |
| **Payload**  | 链接器 -> 常规       | 附加库目录       | `$(ProjectDir)lib\MinHook`   | 让链接器能找到 .lib    |
| **Payload**  | 链接器 -> 输入       | 附加依赖项       | `MinHook.x86.lib`            | 链接 MinHook           |
| **Both**     | 顶栏工具条           | 解决方案平台     | **x86**                  | 必须是 32 位           |
| **Both**     | 属性 -> 常规         | 字符集           | **使用 Unicode 字符集**  | 支持中文路径           |
| **Both**     | C/C++ -> 代码生成    | 运行库           | **多线程 (/MT)**         | 静态链接，避免缺少 DLL |
| **Injector** | 链接器 -> 清单文件   | UAC 执行级别     | **requireAdministrator** | 自动请求管理员权限     |

---

## 构建流程（建议执行顺序）

1. **设置平台**：解决方案平台统一为 `x86`。
2. **构建 Payload**：生成 `game-payload.dll`。
3. **构建 Injector**：生成 `game-injector.exe`。
4. **构建 MasterGUI**：目标框架统一 `net8.0-windows`。
5. **输出检查**：确认三组件文件名与目录一致。

---

## 第五阶段：共享内存一致性检查

这是最后一步，确保 GUI 能控制 DLL。

1. 在 `Payload/modules/helper/HelperMod.cpp` 中搜索 `CreateFileMapping`，确认名称为：
   `"Global\\GameHelperStatus_"` (或者您定义的特定名称)
2. 在 `GUI` 项目的 C# 代码中，确保 `SharedMemoryReader` 使用**完全相同**的字符串前缀。

完成以上步骤后，点击 Visual Studio 的  **"生成解决方案"** ，您将在 Release 目录下得到 `game-payload.dll` 和 `game-injector.exe`，直接运行 Injector 即可开始使用。

---

## MasterGUI 半集成说明

**定位**：MasterGUI 负责“控制与展示”，不直接接管注入器逻辑。

**具体行为**：

1. 提供“快捷入口”按钮（例如：打开注入器目录或提示运行 Injector）。
2. 通过共享内存检测状态：
   - Helper：读取 `GameHelperStatus_{pid}` 心跳或状态字段。
   - Sync：读取 `DNFSyncBox.KeyboardState.V2` 心跳或序列号变化。
3. 状态栏展示：
   - 未注入 / 运行中 / 超时失联 等状态提示。

**优势**：

- 权限与安全风险更低。
- 工程耦合更小，便于后期维护。
- 用户体验改善但不牺牲稳定性。

---

## GUI 集成细则（工程落地）

1. **主窗口结构**：
   - 使用 `TabControl` 承载两个模块页：Helper / Sync。
   - 底部统一状态栏展示注入状态与心跳结果。
2. **状态展示来源**：
   - Helper：读取 `GameHelperStatus_{pid}` 心跳或状态字段。
   - Sync：读取 `DNFSyncBox.KeyboardState.V2` 的 `LastTick/Seq`。
3. **快捷入口**：
   - 提供“打开注入器目录”或“提示运行 Injector”的按钮。
   - 不直接触发注入逻辑。
4. **异常提示**：
   - 共享内存不存在：提示“未注入或未启动”。
   - 心跳超时：提示“失联/异常”。

---

## 验收标准（完成定义）

1. **构建一致**：三组件在 `x86` 下成功编译。
2. **框架一致**：所有 GUI 项目目标框架统一为 `net8.0-windows`。
3. **协议一致**：C++/C# 与 `Shared/Protocols/协议说明.md` 对齐，版本/大小校验生效。
4. **GUI 可用**：主窗口正常加载两个模块页，状态栏有实时状态更新。
5. **半集成生效**：GUI 提供快捷入口且不会直接操控注入逻辑。
