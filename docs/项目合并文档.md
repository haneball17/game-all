
---

# ⚔️ game-all 完整工程合并方案

## 🎯 项目目标

构建一个名为 `game-all` 的解决方案，包含以下三个核心组件：

1. **Payload (game-payload.dll)** : x86 DLL，合并了游戏辅助 (Helper) 和同步器 (Sync) 的核心逻辑。
2. **Injector (game-injector.exe)** : x86 控制台程序，采用 APC 技术将 DLL 注入游戏。
3. **MasterGUI (game-master.exe)** : C# WPF 程序，提供双功能控制面板。

---

## ✅ 工程落地决策（已确认）

1. **协议单一来源方式**：不引入自动生成体系，采用 **Shared/Protocols/** 作为协议“单一来源”。
   - 目标：减少 C++/C# 结构体不一致风险，确保版本一致性。
   - 要求：所有共享内存结构体定义与版本号必须集中维护在 `Shared/Protocols/`。
2. **MasterGUI 与 Injector 关系**：采用**半集成**模式。
   - MasterGUI 仅提供“快捷入口（打开注入器目录/按钮）”与“状态检测提示”。
   - MasterGUI **不直接负责**启动/停止注入器逻辑，降低权限与耦合风险。
3. **GUI 目标框架统一**：所有 GUI 项目统一为 **net8.0-windows**。
   - 目标：减少运行时差异与发布复杂度。
   - 要求：统一 `TargetFramework`，并同步更新相关依赖。

## ✅ 近期决策（2026-02-03）

1. **Sync 模块回退到 V2（Payload + 控制端/配置）**：
   - 回退同步核心逻辑，同时控制端与配置同步回退到 V2。
   - 保留现有配置读取与日志路径。
   - 先恢复稳定性，再逐项优化（优化需可开关）。
   - 落地方案见：`docs/SyncMod-V2回退方案.md`

---

## 第一阶段：目录结构重组 (手动操作)

请在磁盘上创建一个名为 `game-all` 的文件夹，并严格按以下结构组织文件。

> **⚠️ 注意** ：标有 `[搬运]` 的文件需要您从原项目中复制过来。

**Plaintext**

```
game-all/
├── 📁 Shared/
│   └── 📁 Protocols/                 <-- [新建] 协议单一来源（C++/C# 对齐）
├── 📁 Payload/                       <-- [C++ DLL 项目] 输出: game-payload.dll
│   ├── 📁 lib/                       <-- 第三方库目录
│   │   └── 📁 MinHook/               <-- MinHook 库 (必须放这里)
│   │       ├── MinHook.h             <-- [搬运]
│   │       └── MinHook.x86.lib       <-- [搬运]
│   ├── 📁 modules/
│   │   ├── 📁 helper/                <-- [搬运] 原 version-inject 目录下的 .h/.cpp
│   │   │   └── HelperMod.cpp         <-- [重命名] 由 version_proxy.cpp 改名而来
│   │   └── 📁 sync/                  <-- [搬运] 原 dnfinput 目录下的 .h/.cpp
│   │       └── SyncMod.cpp           <-- [重命名] 由 dnfinput.cpp 改名而来
│   ├── dllmain.cpp                   <-- [新建] 统一入口 (代码见下文)
│   ├── pch.h                         <-- [新建] 预编译头 (代码见下文)
│   └── pch.cpp                       <-- [新建] 预编译源文件
│
├── 📁 Injector/                      <-- [C++ Console 项目] 输出: game-injector.exe
│   └── main.cpp                      <-- [新建] APC 注入器源码 (代码见下文)
│
└── 📁 GUI/                           <-- [C# WPF 项目] 输出: game-master.exe
    ├── App.xaml
    ├── MainWindow.xaml               <-- [修改] 包含 TabControl 的主界面
    ├── 📁 Modules/
    │   ├── 📁 Helper/                <-- [搬运] 原 GameHelperGUI 代码
    │   └── 📁 Sync/                  <-- [搬运] 原 DNFSyncBox 代码
    └── ...
```

---

## 协议单一来源（Shared/Protocols）

**目标**：统一 C++ 与 C# 的共享内存结构定义与版本号，降低结构体错位风险。

**做法**：

1. 在 `Shared/Protocols/` 中维护协议定义文档（建议按模块拆分）：
   - `HelperStatusV2`、`HelperControlV1/HelperControlV2`
   - `SharedKeyboardStateV2`
   - **说明**：`HelperControlV2` 在 V1 基础上新增动作区（ActionSequence/ActionMask/Desired*），用于 UI/热键共享状态与一次性切换命令。
2. **强制版本与大小校验**：
   - GUI 端：读取/写入时校验 `Version` 与 `Size`。
   - Payload 端：写入/读取共享内存时，同样进行 `Version` 与 `Size` 校验。
3. 任何协议变更必须先更新 `Shared/Protocols/`，再改代码。
   - **Sync 协议回退为 V2（快照驱动）**：映射名称 `Local\\DNFSyncBox.KeyboardState.V2`。

**示例**（通俗说明）：

> “结构体定义就像一张表格，C++ 和 C# 都必须用同一份模板，否则字段会错位。”

---

## 协议引用（必读）

**唯一权威**：`Shared/Protocols/协议说明.md`

**要求**：

- 协议字段、版本号、大小校验必须以该文件为准。
- 任何代码变更前，先更新协议说明，再同步 C++ 与 C# 实现。
- 代码审查时以协议说明为对照，确保字段顺序与类型一致。

---

## 第二阶段：Payload (DLL) 代码改造

### 1. 配置预编译头 (`Payload/pch.h`)

在 VS 中设置项目使用预编译头，内容如下：

**C++**

```
#pragma once
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <vector>
#include <string>
#include <iostream>

// 引入 MinHook (路径已在第一阶段规划好)
#include "../lib/MinHook/MinHook.h"
```

### 2. 改造 Helper 模块 (`HelperMod.cpp`)

 **操作对象** ：`Payload/modules/helper/HelperMod.cpp` (原 `version_proxy.cpp`)

* **修改点 1** ：删除 `#include "version_exports.h"` 及所有 `#pragma comment(linker, ...)`。
* **修改点 2** ：在文件首尾添加 `namespace Helper { ... }`。
* **修改点 3** ：删除原有的 `DllMain`，改为 `Start` 函数。

**C++**

```
// 在 namespace Helper { 内部的末尾 ...

    // [新增] 启动接口
    void Start() {
        // 模拟原 DllMain 的初始化逻辑
        // 注意：g_self_module 变量需要在本文件顶部声明过
        g_self_module = GetModuleHandleA(NULL); 
      
        // 启动工作线程 (保留原逻辑)
        HANDLE thread = CreateThread(NULL, 0, WorkerThread, NULL, 0, NULL);
        if (thread) CloseHandle(thread);
    }

    void Stop() {
        // 清理逻辑
    }
} // namespace Helper 结束
```

### 3. 改造 Sync 模块 (`SyncMod.cpp`)

 **操作对象** ：`Payload/modules/sync/SyncMod.cpp` (原 `dnfinput.cpp`)

* 同样包裹 `namespace Sync { ... }`。
* 删除 `DllMain`，将初始化逻辑封装进 `Sync::Start()`。

### 4. 编写统一入口 (`Payload/dllmain.cpp`)

**C++**

```
#include "pch.h"
#include <atomic>

// 声明子模块接口
namespace Helper { void Start(); void Stop(); }
namespace Sync   { void Start(); void Stop(); }

std::atomic<bool> g_IsInitialized(false);

DWORD WINAPI UnifiedInitThread(LPVOID lpParam) {
    // 1. 初始化 MinHook (只需一次)
    if (MH_Initialize() != MH_OK) {
        OutputDebugStringA("[game-all] MinHook init failed!");
    }

    // 2. 启动同步模块 (建议先启动 Input Hook)
    Sync::Start();

    // 3. 启动辅助模块
    Helper::Start();

    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        // 原子锁防止 APC 重复触发
        bool expected = false;
        if (g_IsInitialized.compare_exchange_strong(expected, true)) {
            DisableThreadLibraryCalls(hModule);
            // 开启新线程进行初始化，避免 Loader Lock 死锁
            CreateThread(NULL, 0, UnifiedInitThread, NULL, 0, NULL);
        }
        break;
    }
    return TRUE;
}
```

---

## 第三阶段：Injector (注入器) 代码实现

 **操作对象** ：`Injector/main.cpp`

这是基于 `APCinjecter.cpp` 优化后的版本，增加了提权和等待功能。

**C++**

```
#include <windows.h>
#include <tlhelp32.h>
#include <vector>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>

// 日志辅助
void Log(const std::wstring& msg) { std::wcout << L"[Injector] " << msg << std::endl; }

// 1. 提权 (SeDebugPrivilege)
bool EnableDebugPrivilege() {
    HANDLE hToken;
    TOKEN_PRIVILEGES tp;
    LUID luid;
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) return false;
    if (!LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &luid)) { CloseHandle(hToken); return false; }
    tp.PrivilegeCount = 1;
    tp.Privileges[0].Luid = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
    if (!AdjustTokenPrivileges(hToken, FALSE, &tp, sizeof(TOKEN_PRIVILEGES), NULL, NULL)) { CloseHandle(hToken); return false; }
    CloseHandle(hToken);
    return (GetLastError() == ERROR_SUCCESS);
}

// 2. 查找 PID
DWORD FindProcessId(const std::wstring& processName) {
    PROCESSENTRY32W pe32 = { sizeof(PROCESSENTRY32W) };
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) return 0;
    DWORD pid = 0;
    if (Process32FirstW(hSnapshot, &pe32)) {
        do {
            if (processName == pe32.szExeFile) { pid = pe32.th32ProcessID; break; }
        } while (Process32NextW(hSnapshot, &pe32));
    }
    CloseHandle(hSnapshot);
    return pid;
}

// 3. APC 注入
bool PerformApcInjection(DWORD pid, const std::wstring& dllPath) {
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    if (!hProcess) return false;

    size_t size = (dllPath.length() + 1) * sizeof(wchar_t);
    LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT, PAGE_READWRITE);
    if (!remoteMem) { CloseHandle(hProcess); return false; }

    if (!WriteProcessMemory(hProcess, remoteMem, dllPath.c_str(), size, NULL)) {
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        CloseHandle(hProcess);
        return false;
    }

    // ⚠️ 关键：必须编译为 x86，否则 kernel32 地址不匹配
    PAPCFUNC pLoadLibrary = (PAPCFUNC)GetProcAddress(GetModuleHandleW(L"kernel32.dll"), "LoadLibraryW");
  
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    THREADENTRY32 te32 = { sizeof(THREADENTRY32) };
    int queued = 0;

    if (Thread32First(hSnapshot, &te32)) {
        do {
            if (te32.th32OwnerProcessID == pid) {
                HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);
                if (hThread) {
                    if (QueueUserAPC(pLoadLibrary, hThread, (ULONG_PTR)remoteMem)) queued++;
                    CloseHandle(hThread);
                }
            }
        } while (Thread32Next(hSnapshot, &te32));
    }
    CloseHandle(hSnapshot);
    CloseHandle(hProcess);
    return queued > 0;
}

int main() {
    SetConsoleTitleW(L"game-all Injector");
    if (!EnableDebugPrivilege()) Log(L"Warning: Failed to enable Debug Privilege.");

    wchar_t path[MAX_PATH];
    GetCurrentDirectoryW(MAX_PATH, path);
    std::wstring dllPath = std::wstring(path) + L"\\game-payload.dll"; // 目标 DLL 名称

    Log(L"Waiting for DNF.exe...");
    DWORD pid = 0;
    while ((pid = FindProcessId(L"DNF.exe")) == 0) {
        std::this_thread::sleep_for(std::chrono::milliseconds(1000));
    }

    Log(L"Found PID: " + std::to_wstring(pid));
    std::this_thread::sleep_for(std::chrono::milliseconds(2000)); // 等待初始化

    if (PerformApcInjection(pid, dllPath)) Log(L"Injection Success!");
    else Log(L"Injection Failed.");

    std::this_thread::sleep_for(std::chrono::seconds(3));
    return 0;
}
```

---

### 注入结果判定（当前实施）

为提高“模块隐藏”场景的稳定性，注入结果采用 **成功文件为主、共享内存心跳兜底**：

1. **成功文件（主判定）**  
   - 文件名：`successfile_%dll.name%_%pid%.txt`  
   - 默认目录：**DLL 所在目录下的 `logs` 子目录**（可通过 `injector.ini` 的 `output_dir` 覆盖）
   - 判定方式：记录注入前基线时间，注入后等待文件**新建或更新时间变化**。

2. **共享内存心跳（兜底）**  
   - 读取 `GameHelperStatus_{pid}`（Global/Local）  
   - 校验 `Version=3` 且 `Size=136`  
   - `LastTickMs` 距当前时间不超过阈值则判定成功

---

### Injector 配置（injector.ini）

注入器运行时读取同目录下 `injector.ini`，主要配置项如下：  
**模板文件**：`Injector/injector.ini`（构建后请复制到注入器输出目录）。

> 说明：当 `watch_mode=true` 时，注入器会**常驻监听**目标进程列表；  
> 若在 `idle_exit_seconds` 时间内**没有出现新的目标进程**，注入器将自动退出。

### 日志输出规范（统一 ./logs）

- **会话标识**：`./logs/session.current`（每次启动 MasterGUI 生成一次）
- **会话归档**：`./logs/session_<sessionId>/`（退出时复制对应会话日志）
- **MasterGUI（Debug）**：`./logs/master/master_<sessionId>_<pid>.log`
- **Injector（Debug）**：`./logs/injector/injector_<sessionId>_<pid>.log`
- **Payload（Debug）**：`./logs/payload/payload_<sessionId>_<pid>.log`
- **Helper（Payload）**：`./logs/helper/helper_<sessionId>_<pid>.log.jsonl`
- **Sync（GUI）**：`./logs/sync/gui/sync_gui_<sessionId>_<pid>.log`
- **Sync（Payload）**：`./logs/sync/payload/sync_payload_<sessionId>_<pid>.log`
- **成功文件**：默认 `DLL\\logs\\successfile_<dll>_<pid>.txt`

| 键 | 说明 | 默认值 |
| --- | --- | --- |
| process_name | 目标进程名（自动补 `.exe`） | `DNF.exe` |
| dll_path | 注入 DLL 路径（可相对） | `..\\payload\\game-payload.dll` |
| output_dir | 成功文件目录（空则使用 DLL\\logs 目录） | 空 |
| scan_interval_ms | 扫描进程间隔 | `1000` |
| inject_delay_ms | 发现进程后的注入延迟 | `2000` |
| max_retries | 重试次数 | `3` |
| retry_interval_ms | 重试间隔 | `1000` |
| success_timeout_ms | 成功文件判定超时 | `6000` |
| success_interval_ms | 成功文件轮询间隔 | `200` |
| heartbeat_timeout_ms | 心跳兜底超时 | `6000` |
| heartbeat_interval_ms | 心跳轮询间隔 | `200` |
| watch_mode | 是否常驻监听新进程 | `true` |
| idle_exit_seconds | 无新目标进程出现后自动退出（秒，0 不退出） | `600` |

---

## 第四阶段：Visual Studio 关键配置检查

为保证编译通过且运行正常，请对 `Payload` 和 `Injector` 项目执行以下检查：

| **项目**     | **属性页路径** | **设置项** | **值**                   | **说明**         |
| ------------------ | -------------------- | ---------------- | ------------------------------ | ---------------------- |
| **Payload**  | C/C++ -> 常规        | 附加包含目录     | `$(ProjectDir)lib\MinHook`   | 让代码能找到 MinHook.h |
| **Payload**  | 链接器 -> 常规       | 附加库目录       | `$(ProjectDir)lib\MinHook`   | 让链接器能找到 .lib    |
| **Payload**  | 链接器 -> 输入       | 附加依赖项       | `MinHook.x86.lib`            | 链接 MinHook           |
| **Both**     | 顶栏工具条           | 解决方案平台     | **x86**                  | 必须是 32 位           |
| **Both**     | 属性 -> 常规         | 字符集           | **使用 Unicode 字符集**  | 支持中文路径           |
| **Both**     | C/C++ -> 代码生成    | 运行库           | **多线程 (/MT)**         | 静态链接，避免缺少 DLL |
| **Injector** | 链接器 -> 清单文件   | UAC 执行级别     | **requireAdministrator** | 自动请求管理员权限     |

---

## 构建流程（建议执行顺序）

1. **设置平台**：解决方案平台统一为 `x86`。
2. **构建 Payload**：生成 `game-payload.dll`。
3. **构建 Injector**：生成 `game-injector.exe`。
4. **构建 MasterGUI**：目标框架统一 `net8.0-windows`。
5. **输出检查**：确认三组件文件名与目录一致。

---

## 构建前置条件

1. **工具链**：Visual Studio 2022（v143）与 C++ 工作负载已安装。
2. **平台**：解决方案平台选择 `x86`。
3. **MinHook 依赖**（Payload）：
   - `Payload/lib/minhook/include/MinHook.h`
   - `Payload/lib/minhook/lib/libMinHook.x86.lib`
   - 说明：`Payload/Payload.vcxproj` 已配置 `include` 与 `lib` 搜索路径，需按上述目录放置文件。
4. **.NET 运行时**：目标框架 `net8.0-windows` 已安装。

---

## 如何生成 MinHook 库

1. 打开解决方案：`Payload/lib/minhook/build/VC17/MinHookVC17.sln`
2. 选择平台：`Win32`，配置：`Release`
3. 在解决方案资源管理器中选中 **libMinHook** 项目并执行构建
4. 产物路径（示例）：
   - `Payload/lib/minhook/build/VC17/lib/Release/libMinHook.x86.lib`
5. 确认头文件存在：
   - `Payload/lib/minhook/include/MinHook.h`

**提示**：

- `Payload/Payload.vcxproj` 已配置 `include` 与 `build` 路径回退，确保能找到头文件与库。
- 若库名不同，请同步更新 `Payload/Payload.vcxproj` 的 `AdditionalDependencies`。

---

## 常见编译错误排查

1. **MinHook 找不到头文件或库**
   - 现象：`MinHook.h` 或 `libMinHook.x86.lib` 找不到。
   - 处理：确认以下路径存在文件：
     - `Payload/lib/minhook/include/MinHook.h`
     - `Payload/lib/minhook/build/VC17/lib/Release/libMinHook.x86.lib`
2. **平台不匹配（x64 / Any CPU）**
   - 现象：链接失败或运行时崩溃。
   - 处理：解决方案平台选择 `x86`，并确保 `.NET` 项目已设置 `PlatformTarget=x86`。
3. **工具链缺失**
   - 现象：提示找不到 `v143` 或 Windows SDK。
   - 处理：安装 VS2022 C++ 工作负载与对应 Windows SDK。
4. **清单权限问题（Injector）**
   - 现象：注入器启动无权限或提示 UAC。
   - 处理：确认 `Injector/app.manifest` 已嵌入并设置 `requireAdministrator`。

---

## 顶层解决方案与输出目录规范

**解决方案文件**：`game-all.sln`

**平台要求**：

- 解决方案平台统一为 `x86`。
- .NET 项目平台保持 `Any CPU`，但 `PlatformTarget` 强制为 `x86`。
- C++ 项目平台为 `Win32`。

**输出目录**（统一收敛到 `artifacts/`）：

- `GUI` 相关输出：`artifacts/bin/`
- `Payload` 输出：`artifacts/bin/payload/`
- `Injector` 输出：`artifacts/bin/injector/`
- 中间产物：`artifacts/obj/`

**说明**：

- .NET 输出路径通过 `Directory.Build.props` 统一。
- C++ 输出路径在 `*.vcxproj` 中显式指定。

---

## 第五阶段：共享内存一致性检查

这是最后一步，确保 GUI 能控制 DLL。

1. 在 `Payload/modules/helper/HelperMod.cpp` 中搜索 `CreateFileMapping`，确认名称为：
   `"Global\\GameHelperStatus_"` (或者您定义的特定名称)
2. 在 `GUI` 项目的 C# 代码中，确保 `SharedMemoryReader` 使用**完全相同**的字符串前缀。

完成以上步骤后，点击 Visual Studio 的  **"生成解决方案"** ，您将在 Release 目录下得到 `game-payload.dll` 和 `game-injector.exe`，直接运行 Injector 即可开始使用。

---

## MasterGUI 半集成说明

**定位**：MasterGUI 负责“控制与展示”，不直接接管注入器逻辑。

**具体行为**：

1. 提供“快捷入口”按钮（例如：打开注入器目录或提示运行 Injector）。
2. 通过共享内存检测状态：
   - Helper：读取 `GameHelperStatus_{pid}` 心跳或状态字段。
   - Sync：读取 `DNFSyncBox.KeyboardState.V2` 心跳或序列号变化。
3. 状态栏展示：
   - 未注入 / 运行中 / 超时失联 等状态提示。

**优势**：

- 权限与安全风险更低。
- 工程耦合更小，便于后期维护。
- 用户体验改善但不牺牲稳定性。

---

## GUI 集成细则（工程落地）

1. **主窗口结构**：
   - 使用 `TabControl` 承载两个模块页：Helper / Sync。
   - 底部统一状态栏展示注入状态与心跳结果。
2. **状态展示来源**：
   - Helper：读取 `GameHelperStatus_{pid}` 心跳或状态字段。
   - Sync：读取 `DNFSyncBox.KeyboardState.V2` 的 `LastTick/Seq`。
3. **快捷入口**：
   - 提供“打开注入器目录”或“提示运行 Injector”的按钮。
   - 不直接触发注入逻辑。
4. **异常提示**：
   - 共享内存不存在：提示“未注入或未启动”。
   - 心跳超时：提示“失联/异常”。

---

## MasterGUI 配置项说明

配置文件路径：`GUI/config/mastergui.json`

| 配置项 | 含义 | 默认值 |
| --- | --- | --- |
| TargetProcessNames | 目标进程名列表（不含 .exe），例如 `DNF`/`dnf` | `["DNF","dnf"]` |
| HelperHeartbeatTimeoutMs | Helper 心跳超时阈值（毫秒） | `2000` |
| SyncHeartbeatTimeoutMs | Sync 心跳超时阈值（毫秒） | `2000` |
| StatusIntervalMs | 状态刷新间隔（毫秒） | `1000` |
| SyncMappingName | Sync 共享内存名称 | `Local\\DNFSyncBox.KeyboardState.V2` |
| SyncVersion | Sync 协议版本 | `3` |
| SyncMappingSize | Sync 映射大小（字节） | `1824` |
| InjectorProcessNames | 注入器进程名列表 | `["game-injector","Injector"]` |
| RequireBothModulesForInjected | 是否要求 Helper 与 Sync 同时正常才显示“已注入” | `false` |

## 验收标准（完成定义）

1. **构建一致**：三组件在 `x86` 下成功编译。
2. **框架一致**：所有 GUI 项目目标框架统一为 `net8.0-windows`。
3. **协议一致**：C++/C# 与 `Shared/Protocols/协议说明.md` 对齐，版本/大小校验生效。
4. **GUI 可用**：主窗口正常加载两个模块页，状态栏有实时状态更新。
5. **半集成生效**：GUI 提供快捷入口且不会直接操控注入逻辑。

---

## 近期改动摘要（落地）

1. **Injector 并发注入任务化**
   - 发现新进程后独立线程等待窗口 → 固定等待 10s → 注入
   - 避免单进程阻塞全局扫描
2. **切窗 Grace + 高频前台检测**
   - 切换窗口后短时间内保持有效前台 PID，减少输入空窗
3. **共享心跳超时可配置**
   - 默认提升至 500ms，并支持环境变量覆盖
4. **连发键边沿合成**
   - 支持 RepeatKeys/RepeatIntervalMs，默认 X 连发
5. **性能优化**
   - 共享快照短缓存（默认 2ms）
   - RawInput 日志可开关与采样
6. **Payload 模块总开关**
   - 支持 payload.ini 控制 Helper/Sync 是否启用
   - 关闭模块仍保留 successfile
7. **Helper 线程与 IO 优化**
   - 低频任务合并为后台线程（共享内存写入/控制读取/配置重载/全屏攻击守护）
   - 吸怪与全屏技能逻辑合并调度，减少对象遍历
   - 输入轮询节流与按需读取（非前台/无功能时降低频率）
   - 配置热重载事件化（目录变更通知驱动，失败回退时间戳检测）
   - 日志写入异步化（队列缓冲+后台批量落盘）
8. **Sync 高并发输入路径优化**
   - 轻量快照判定 + 快路径分层，减少高频 Hook 的完整拷贝
   - 共享快照 seq 复用，稳定场景降低 memcpy
   - RawInput 仅在必要场景介入，减少切窗卡顿
   - 消息钩子按需短路（仅处理 WM_INPUT + RIM_INPUTSINK）
   - 统计计数开关化与节流，避免长期常驻开销
   - 暂停态兜底：即便 activePid=0 仍执行阻断逻辑，避免后台误响应
9. **暂停失效修复**
   - 快路径放宽对 activePid 的限制，暂停态仍拦截输入
10. **日志规范升级**
    - 会话标识 `session.current`，按会话归档到 `session_<id>/`
    - 模块日志分目录（master/injector/payload/helper/sync），文件名含 sessionId + pid

---

## 配置模板更新

1. `config-templates/injector.ini`
   - 新增：`window_wait_timeout_ms`、`window_poll_interval_ms`、`post_window_delay_ms`、`max_concurrent_tasks`
   - `inject_delay_ms` 默认改为 0（避免叠加等待）
2. `config-templates/profiles.json`
   - 新增连发键字段：`RepeatKeys`、`RepeatIntervalMs`
3. `config-templates/payload.ini`
   - 新增模块总开关：`EnableHelper`、`EnableSync`

---

## 运行参数（环境变量）

Payload 相关：
- `DNFSYNC_SPOOF_DELAY_MS`：注入后伪造延迟（毫秒）
- `DNFSYNC_HEARTBEAT_TIMEOUT_MS`：共享心跳超时（毫秒）
- `DNFSYNC_SNAPSHOT_CACHE_MS`：共享快照缓存时间（毫秒）
- `DNFSYNC_RAWINPUT_LOG`：RawInput 日志开关（1/true/yes/on）
- `DNFSYNC_RAWINPUT_LOG_INTERVAL_MS`：RawInput 日志采样间隔（毫秒）
- `config/sync_debug.ini`：同步模块调试配置（优先于环境变量）
- `sync_debug.ini` 关键字段：`Stats`/`StatsIntervalMs`、`Diag`/`DiagIntervalMs`、`RawInputLog`/`RawInputLogIntervalMs`、`KeyLog`/`KeyLogIntervalMs`/`KeyLogLevel`/`KeyUpTimeoutMs`
- `DNFSYNC_FORCE_DI_OK`：DirectInput 返回 DIERR_NOTACQUIRED 时强制 DI_OK
- `DNFSYNC_STATS`：Sync 统计日志开关（1/true/yes/on）
- `DNFSYNC_STATS_INTERVAL_MS`：统计日志输出间隔（毫秒）
- `DNFSYNC_DIAG`：Sync 诊断日志开关（1/true/yes/on）
- `DNFSYNC_DIAG_INTERVAL_MS`：诊断日志输出间隔（毫秒）
- `DNFSYNC_KEYLOG`：按键事件日志开关（1/true/yes/on）
- `DNFSYNC_KEYLOG_INTERVAL_MS`：按键事件日志采样间隔（毫秒）
- `DNFSYNC_KEYLOG_LEVEL`：按键日志级别（1=RawInput，2=含 Win32，3=含 DirectInput）
- `DNFSYNC_KEYUP_TIMEOUT_MS`：KeyUp 缺失告警阈值（毫秒）

Sync 配置文件：
- `profiles.json` 默认位置：`%AppData%\\DNFSyncBox\\profiles.json`
- 可参考模板：`config-templates/profiles.json`
