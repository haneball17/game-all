# PEB Unlink ä»£ç æ¨¡æ¿

> **å®Œæ•´çš„PEB Unlinkå®ç°ä»£ç  - å¯ç›´æ¥å¤åˆ¶ä½¿ç”¨**

---

## ğŸ“ æ–‡ä»¶ç»“æ„

```
Payload/modules/stealth/
â”œâ”€â”€ peb_utils.h         # PEBå·¥å…·å¤´æ–‡ä»¶
â”œâ”€â”€ peb_utils.cpp       # PEBå·¥å…·å®ç°
â”œâ”€â”€ module_hider.h      # æ¨¡å—éšè—æ¥å£
â””â”€â”€ module_hider.cpp    # Unlinkå®ç°
```

---

## 1ï¸âƒ£ peb_utils.h

```cpp
#pragma once

#include <windows.h>
#include <winternl.h>
#include <string>

// å‰å‘å£°æ˜
struct PEB_LDR_DATA;
struct LDR_DATA_TABLE_ENTRY;

namespace stealth {

/**
 * @brief PEBè®¿é—®å·¥å…·ç±»
 * 
 * æä¾›å¯¹PEBï¼ˆProcess Environment Blockï¼‰çš„è®¿é—®å’Œæ“ä½œåŠŸèƒ½
 * ä¸»è¦ç”¨äºéå†å’Œç®¡ç†åŠ è½½çš„æ¨¡å—åˆ—è¡¨
 */
class PEBUtils {
public:
    /**
     * @brief è·å–å½“å‰è¿›ç¨‹çš„PEBåœ°å€
     * @return PEBç»“æ„æŒ‡é’ˆï¼Œå¤±è´¥è¿”å›nullptr
     */
    static PVOID GetCurrentPEB();

    /**
     * @brief è·å–Ldræ•°æ®ç»“æ„
     * @param peb PEBæŒ‡é’ˆ
     * @return LDR_DATAæŒ‡é’ˆï¼Œå¤±è´¥è¿”å›nullptr
     */
    static PEB_LDR_DATA* GetLdrData(PVOID peb);

    /**
     * @brief æ¨¡å—éå†å›è°ƒå‡½æ•°ç±»å‹
     * @param entry æ¨¡å—æ¡ç›®
     * @param context ç”¨æˆ·ä¸Šä¸‹æ–‡
     * @return trueç»§ç»­éå†ï¼Œfalseåœæ­¢éå†
     */
    using ModuleEnumCallback = bool (*)(LDR_DATA_TABLE_ENTRY* entry, void* context);

    /**
     * @brief éå†æ‰€æœ‰åŠ è½½çš„æ¨¡å—
     * @param callback å›è°ƒå‡½æ•°
     * @param context ç”¨æˆ·ä¸Šä¸‹æ–‡
     * @return æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
     */
    static bool EnumModules(ModuleEnumCallback callback, void* context);

    /**
     * @brief é€šè¿‡æ¨¡å—åæŸ¥æ‰¾æ¨¡å—
     * @param moduleName æ¨¡å—åï¼ˆå¦‚L"game-payload.dll"ï¼‰
     * @return æ¨¡å—æ¡ç›®æŒ‡é’ˆï¼Œæœªæ‰¾åˆ°è¿”å›nullptr
     */
    static LDR_DATA_TABLE_ENTRY* FindModuleByName(const wchar_t* moduleName);

    /**
     * @brief é€šè¿‡åŸºåœ°å€æŸ¥æ‰¾æ¨¡å—
     * @param baseAddress æ¨¡å—åŸºåœ°å€
     * @return æ¨¡å—æ¡ç›®æŒ‡é’ˆï¼Œæœªæ‰¾åˆ°è¿”å›nullptr
     */
    static LDR_DATA_TABLE_ENTRY* FindModuleByBaseAddress(PVOID baseAddress);

    /**
     * @brief è·å–å½“å‰æ¨¡å—çš„åŸºåœ°å€
     * @return æ¨¡å—åŸºåœ°å€
     */
    static PVOID GetCurrentModuleBase();
};

} // namespace stealth
```

---

## 2ï¸âƒ£ peb_utils.cpp

```cpp
#include "peb_utils.h"
#include <stdio.h>

// NTAPIå‡½æ•°æŒ‡é’ˆç±»å‹
typedef NTSTATUS (NTAPI* FnNtQueryInformationProcess)(
    HANDLE ProcessHandle,
    DWORD ProcessInformationClass,
    PVOID ProcessInformation,
    DWORD ProcessInformationLength,
    PDWORD ReturnLength
);

// è¿›ç¨‹ä¿¡æ¯ç±»
#define ProcessBasicInformation 0

// è¿›ç¨‹åŸºç¡€ä¿¡æ¯ç»“æ„
struct PROCESS_BASIC_INFORMATION {
    PVOID Reserved1;
    PVOID PebBaseAddress;
    PVOID Reserved2[2];
    ULONG_PTR UniqueProcessId;
    PVOID Reserved3;
};

// PEBç»“æ„ï¼ˆç®€åŒ–ç‰ˆï¼Œä»…åŒ…å«å¿…éœ€å­—æ®µï¼‰
struct PEB {
    BYTE InheritedAddressSpace;
    BYTE ReadImageFileExecOptions;
    BYTE BeingDebugged;
    BYTE SpareBool;
    PVOID Mutant;
    PVOID ImageBaseAddress;
    PEB_LDR_DATA* Ldr;
    // ... å…¶ä»–å­—æ®µçœç•¥
};

// PEB_LDR_DATAç»“æ„
struct PEB_LDR_DATA {
    ULONG Length;
    BOOLEAN Initialized;
    PVOID SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
};

// LDR_DATA_TABLE_ENTRYç»“æ„ï¼ˆx86ç‰ˆæœ¬ï¼‰
struct LDR_DATA_TABLE_ENTRY {
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    PVOID DllBase;
    PVOID EntryPoint;
    ULONG SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
};

namespace stealth {

PVOID PEBUtils::GetCurrentPEB() {
    // æ–¹æ³•1: é€šè¿‡__readfsdwordç›´æ¥è¯»å–ï¼ˆx86ï¼‰
    #ifdef _M_IX86
        return (PVOID)__readfsdword(0x30);  // PEBä½äºFS:[0x30]
    #elif defined(_M_X64)
        return (PVOID)__readgsqword(0x60);  // PEBä½äºGS:[0x60] (x64)
    #else
        // æ–¹æ³•2: é€šè¿‡NtQueryInformationProcessï¼ˆé€šç”¨ä½†è¾ƒæ…¢ï¼‰
        static FnNtQueryInformationProcess pNtQueryInformationProcess = nullptr;
        if (!pNtQueryInformationProcess) {
            HMODULE hNtdll = GetModuleHandleW(L"ntdll.dll");
            if (hNtdll) {
                pNtQueryInformationProcess = 
                    (FnNtQueryInformationProcess)GetProcAddress(
                        hNtdll, 
                        "NtQueryInformationProcess"
                    );
            }
        }
        
        if (pNtQueryInformationProcess) {
            PROCESS_BASIC_INFORMATION pbi;
            ZeroMemory(&pbi, sizeof(pbi));
            DWORD retLen = 0;
            NTSTATUS status = pNtQueryInformationProcess(
                GetCurrentProcess(),
                ProcessBasicInformation,
                &pbi,
                sizeof(pbi),
                &retLen
            );
            
            if (status == 0) {
                return pbi.PebBaseAddress;
            }
        }
        return nullptr;
    #endif
}

PEB_LDR_DATA* PEBUtils::GetLdrData(PVOID peb) {
    if (!peb) return nullptr;
    
    PEB* pPeb = (PEB*)peb;
    return pPeb->Ldr;
}

bool PEBUtils::EnumModules(ModuleEnumCallback callback, void* context) {
    PVOID peb = GetCurrentPEB();
    if (!peb) {
        printf("[PEBUtils] Failed to get PEB\n");
        return false;
    }
    
    PEB_LDR_DATA* ldr = GetLdrData(peb);
    if (!ldr || !ldr->Initialized) {
        printf("[PEBUtils] LDR not initialized\n");
        return false;
    }
    
    // éå†InLoadOrderModuleList
    LIST_ENTRY* head = &ldr->InLoadOrderModuleList;
    LIST_ENTRY* current = head->Flink;
    
    int moduleCount = 0;
    while (current != head) {
        LDR_DATA_TABLE_ENTRY* entry = CONTAINING_RECORD(
            current, 
            LDR_DATA_TABLE_ENTRY, 
            InLoadOrderLinks
        );
        
        if (entry && entry->DllBase) {
            moduleCount++;
            
            // è°ƒç”¨å›è°ƒ
            if (!callback(entry, context)) {
                break;  // ç”¨æˆ·è¦æ±‚åœæ­¢éå†
            }
        }
        
        current = entry->InLoadOrderLinks.Flink;
    }
    
    printf("[PEBUtils] Enumerated %d modules\n", moduleCount);
    return true;
}

LDR_DATA_TABLE_ENTRY* PEBUtils::FindModuleByName(const wchar_t* moduleName) {
    if (!moduleName) return nullptr;
    
    struct FindContext {
        const wchar_t* targetName;
        LDR_DATA_TABLE_ENTRY* result;
    } findCtx = { moduleName, nullptr };
    
    auto findCallback = [](LDR_DATA_TABLE_ENTRY* entry, void* context) -> bool {
        FindContext* ctx = (FindContext*)context;
        if (!entry || !entry->BaseDllName.Buffer) return true;
        
        if (_wcsicmp(entry->BaseDllName.Buffer, ctx->targetName) == 0) {
            ctx->result = entry;
            return false;  // æ‰¾åˆ°äº†ï¼Œåœæ­¢éå†
        }
        
        return true;
    };
    
    EnumModules(findCallback, &findCtx);
    return findCtx.result;
}

LDR_DATA_TABLE_ENTRY* PEBUtils::FindModuleByBaseAddress(PVOID baseAddress) {
    if (!baseAddress) return nullptr;
    
    struct FindContext {
        PVOID targetAddr;
        LDR_DATA_TABLE_ENTRY* result;
    } findCtx = { baseAddress, nullptr };
    
    auto findCallback = [](LDR_DATA_TABLE_ENTRY* entry, void* context) -> bool {
        FindContext* ctx = (FindContext*)context;
        if (!entry) return true;
        
        if (entry->DllBase == ctx->targetAddr) {
            ctx->result = entry;
            return false;
        }
        
        return true;
    };
    
    EnumModules(findCallback, &findCtx);
    return findCtx.result;
}

PVOID PEBUtils::GetCurrentModuleBase() {
    HMODULE hModule = NULL;
    GetModuleHandleExW(
        GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
        (LPCWSTR)GetCurrentModuleBase,
        &hModule
    );
    return (PVOID)hModule;
}

} // namespace stealth
```

---

## 3ï¸âƒ£ module_hider.h

```cpp
#pragma once

#include <windows.h>
#include <string>

namespace stealth {

/**
 * @brief æ¨¡å—éšè—å™¨
 * 
 * æä¾›ä»PEBæ¨¡å—åˆ—è¡¨ä¸­éšè—æ¨¡å—çš„åŠŸèƒ½
 */
class ModuleHider {
public:
    /**
     * @brief éšè—å½“å‰æ¨¡å—ï¼ˆä»PEBä¸­unlinkï¼‰
     * @return æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
     */
    static bool HideCurrentModule();

    /**
     * @brief é€šè¿‡æ¨¡å—åéšè—æ¨¡å—
     * @param moduleName æ¨¡å—åï¼ˆå¦‚L"game-payload.dll"ï¼‰
     * @return æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
     */
    static bool HideModuleByName(const wchar_t* moduleName);

    /**
     * @brief é€šè¿‡åŸºåœ°å€éšè—æ¨¡å—
     * @param baseAddress æ¨¡å—åŸºåœ°å€
     * @return æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
     */
    static bool HideModuleByBaseAddress(PVOID baseAddress);

    /**
     * @brief æ£€æŸ¥æ¨¡å—æ˜¯å¦å·²éšè—
     * @param moduleName æ¨¡å—å
     * @return å·²éšè—è¿”å›trueï¼Œæœªéšè—æˆ–ä¸å­˜åœ¨è¿”å›false
     */
    static bool IsModuleHidden(const wchar_t* moduleName);

    /**
     * @brief è·å–é”™è¯¯ä¿¡æ¯
     * @return é”™è¯¯æè¿°å­—ç¬¦ä¸²
     */
    static const wchar_t* GetLastErrorMsg();

private:
    /**
     * @brief æ‰§è¡ŒUnlinkæ“ä½œ
     * @param entry è¦éšè—çš„æ¨¡å—æ¡ç›®
     * @return æˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
     */
    static bool UnlinkModule(LDR_DATA_TABLE_ENTRY* entry);

    /**
     * @brief éªŒè¯é“¾è¡¨å®Œæ•´æ€§
     * @param entry æ¨¡å—æ¡ç›®
     * @return é“¾è¡¨å®Œæ•´è¿”å›trueï¼Œå¦åˆ™è¿”å›false
     */
    static bool ValidateLinks(LDR_DATA_TABLE_ENTRY* entry);

    // çº¿ç¨‹å±€éƒ¨å­˜å‚¨é”™è¯¯ä¿¡æ¯
    static __declspec(thread) wchar_t s_errorMsg[256];
};

} // namespace stealth
```

---

## 4ï¸âƒ£ module_hider.cpp

```cpp
#include "module_hider.h"
#include "peb_utils.h"
#include <stdio.h>
#include <string.h>

namespace stealth {

__declspec(thread) wchar_t ModuleHider::s_errorMsg[256] = {0};

const wchar_t* ModuleHider::GetLastErrorMsg() {
    return s_errorMsg;
}

bool ModuleHider::HideCurrentModule() {
    PVOID baseAddr = PEBUtils::GetCurrentModuleBase();
    if (!baseAddr) {
        swprintf_s(s_errorMsg, L"Failed to get current module base");
        return false;
    }
    
    return HideModuleByBaseAddress(baseAddr);
}

bool ModuleHider::HideModuleByName(const wchar_t* moduleName) {
    if (!moduleName || wcslen(moduleName) == 0) {
        swprintf_s(s_errorMsg, L"Invalid module name");
        return false;
    }
    
    printf("[ModuleHider] Searching for module: %ls\n", moduleName);
    
    LDR_DATA_TABLE_ENTRY* entry = PEBUtils::FindModuleByName(moduleName);
    if (!entry) {
        swprintf_s(s_errorMsg, L"Module not found: %ls", moduleName);
        printf("[ModuleHider] %ls\n", s_errorMsg);
        return false;
    }
    
    printf("[ModuleHider] Found module at: 0x%p\n", entry->DllBase);
    return UnlinkModule(entry);
}

bool ModuleHider::HideModuleByBaseAddress(PVOID baseAddress) {
    if (!baseAddress) {
        swprintf_s(s_errorMsg, L"Invalid base address");
        return false;
    }
    
    printf("[ModuleHider] Searching for module at: 0x%p\n", baseAddress);
    
    LDR_DATA_TABLE_ENTRY* entry = PEBUtils::FindModuleByBaseAddress(baseAddress);
    if (!entry) {
        swprintf_s(s_errorMsg, L"Module not found at address: 0x%p", baseAddress);
        printf("[ModuleHider] %ls\n", s_errorMsg);
        return false;
    }
    
    return UnlinkModule(entry);
}

bool ModuleHider::IsModuleHidden(const wchar_t* moduleName) {
    if (!moduleName) return false;
    
    // å°è¯•æŸ¥æ‰¾æ¨¡å—
    LDR_DATA_TABLE_ENTRY* entry = PEBUtils::FindModuleByName(moduleName);
    
    // å¦‚æœæ‰¾ä¸åˆ°ï¼Œå¯èƒ½æ˜¯å·²ç»éšè—äº†
    if (!entry) {
        return true;
    }
    
    return false;
}

bool ModuleHider::ValidateLinks(LDR_DATA_TABLE_ENTRY* entry) {
    if (!entry) return false;
    
    // æ£€æŸ¥InLoadOrderLinks
    if (entry->InLoadOrderLinks.Flink->Blink != &entry->InLoadOrderLinks) {
        printf("[ModuleHider] InLoadOrderLinks validation failed\n");
        return false;
    }
    if (entry->InLoadOrderLinks.Blink->Flink != &entry->InLoadOrderLinks) {
        printf("[ModuleHider] InLoadOrderLinks validation failed\n");
        return false;
    }
    
    // æ£€æŸ¥InMemoryOrderLinks
    if (entry->InMemoryOrderLinks.Flink->Blink != &entry->InMemoryOrderLinks) {
        printf("[ModuleHider] InMemoryOrderLinks validation failed\n");
        return false;
    }
    if (entry->InMemoryOrderLinks.Blink->Flink != &entry->InMemoryOrderLinks) {
        printf("[ModuleHider] InMemoryOrderLinks validation failed\n");
        return false;
    }
    
    // æ£€æŸ¥InInitializationOrderLinks
    if (entry->InInitializationOrderLinks.Flink->Blink != &entry->InInitializationOrderLinks) {
        printf("[ModuleHider] InInitializationOrderLinks validation failed\n");
        return false;
    }
    if (entry->InInitializationOrderLinks.Blink->Flink != &entry->InInitializationOrderLinks) {
        printf("[ModuleHider] InInitializationOrderLinks validation failed\n");
        return false;
    }
    
    return true;
}

bool ModuleHider::UnlinkModule(LDR_DATA_TABLE_ENTRY* entry) {
    if (!entry) {
        swprintf_s(s_errorMsg, L"Null entry pointer");
        return false;
    }
    
    if (!ValidateLinks(entry)) {
        swprintf_s(s_errorMsg, L"Links already corrupted or module already hidden");
        printf("[ModuleHider] %ls\n", s_errorMsg);
        return false;
    }
    
    printf("[ModuleHider] Module info:\n");
    printf("  Base: 0x%p\n", entry->DllBase);
    printf("  Size: 0x%X\n", entry->SizeOfImage);
    printf("  Name: %ls\n", entry->BaseDllName.Buffer ? entry->BaseDllName.Buffer : L"(null)");
    printf("  Path: %ls\n", entry->FullDllName.Buffer ? entry->FullDllName.Buffer : L"(null)");
    
    // 1. Unlink from InLoadOrderModuleList
    printf("[ModuleHider] Unlinking from InLoadOrderModuleList...\n");
    entry->InLoadOrderLinks.Blink->Flink = entry->InLoadOrderLinks.Flink;
    entry->InLoadOrderLinks.Flink->Blink = entry->InLoadOrderLinks.Blink;
    
    // 2. Unlink from InMemoryOrderModuleList
    printf("[ModuleHider] Unlinking from InMemoryOrderModuleList...\n");
    entry->InMemoryOrderLinks.Blink->Flink = entry->InMemoryOrderLinks.Flink;
    entry->InMemoryOrderLinks.Flink->Blink = entry->InMemoryOrderLinks.Blink;
    
    // 3. Unlink from InInitializationOrderModuleList
    printf("[ModuleHider] Unlinking from InInitializationOrderModuleList...\n");
    entry->InInitializationOrderLinks.Blink->Flink = entry->InInitializationOrderLinks.Flink;
    entry->InInitializationOrderLinks.Flink->Blink = entry->InInitializationOrderLinks.Blink;
    
    // éªŒè¯Unlinkç»“æœ
    printf("[ModuleHider] Verifying unlink...\n");
    
    // æ£€æŸ¥æ˜¯å¦å·²ä¸åœ¨é“¾è¡¨ä¸­
    bool unlinked = true;
    
    // å°è¯•é‡æ–°æŸ¥æ‰¾è¯¥æ¨¡å—
    if (entry->BaseDllName.Buffer) {
        LDR_DATA_TABLE_ENTRY* found = PEBUtils::FindModuleByName(entry->BaseDllName.Buffer);
        if (found == entry) {
            printf("[ModuleHider] WARNING: Module still found in PEB!\n");
            unlinked = false;
        }
    }
    
    if (unlinked) {
        printf("[ModuleHider] Successfully unlinked module from PEB\n");
        printf("[ModuleHider] Module is now hidden from EnumProcessModules\n");
        return true;
    } else {
        swprintf_s(s_errorMsg, L"Failed to unlink module");
        return false;
    }
}

} // namespace stealth
```

---

## ğŸ“‹ ä½¿ç”¨ç¤ºä¾‹

### åœ¨Helperæ¨¡å—ä¸­é›†æˆ

```cpp
// modules/helper/helper.cpp

#include "../stealth/module_hider.h"

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
        {
            // åŸæœ‰åˆå§‹åŒ–ä»£ç ...
            
            // æ–°å¢ï¼šéšè—æ¨¡å—
            #ifdef ENABLE_STEALTH_MODE
            printf("[Helper] Enabling stealth mode...\n");
            if (stealth::ModuleHider::HideCurrentModule()) {
                printf("[Helper] Successfully hidden from module list\n");
            } else {
                printf("[Helper] Failed to hide: %ls\n", 
                       stealth::ModuleHider::GetLastErrorMsg());
            }
            #endif
            
            break;
        }
    case DLL_PROCESS_DETACH:
        // æ¸…ç†ä»£ç ...
        break;
    }
    return TRUE;
}
```

---

## âš ï¸ é‡è¦è¯´æ˜

### ç¼–è¯‘é…ç½®

ç¡®ä¿åœ¨é¡¹ç›®é…ç½®ä¸­æ·»åŠ ï¼š
```
Preprocessor Definitions: ENABLE_STEALTH_MODE=1
```

### ä¾èµ–å¤´æ–‡ä»¶

éœ€è¦åŒ…å«ä»¥ä¸‹Windowså¤´æ–‡ä»¶ï¼š
- `<windows.h>`
- `<winternl.h>`
- `<stdio.h>`
- `<intrin.h>` (ç”¨äº__readfsdword)

### å¹³å°æ”¯æŒ

- âœ… x86 (32ä½): å®Œå…¨æ”¯æŒ
- âš ï¸ x64 (64ä½): éœ€è¦è°ƒæ•´PEBç»“æ„åç§»

---

## ğŸ¯ å¿«é€Ÿå¼€å§‹

1. å¤åˆ¶ä¸Šè¿°4ä¸ªæ–‡ä»¶åˆ° `Payload/modules/stealth/` ç›®å½•
2. æ›´æ–° `Payload.vcxproj` æ·»åŠ è¿™äº›æ–‡ä»¶
3. åœ¨Helperæˆ–Syncæ¨¡å—çš„DllMainä¸­è°ƒç”¨ `HideCurrentModule()`
4. ç¼–è¯‘å¹¶æµ‹è¯•

è¯¦ç»†æ­¥éª¤è¯·å‚è€ƒ [02-å¿«é€Ÿå¼€å§‹.md](./02-å¿«é€Ÿå¼€å§‹.md)

---

**ç‰ˆæœ¬**: 1.0  
**æœ€åæ›´æ–°**: 2026-02-18
